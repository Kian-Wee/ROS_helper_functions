#!/usr/bin/env python

## Mode Manager Multiplexer to grab inputs and selectively rebroadcast outputs
  
import os
import rospy
import math
import os
from geometry_msgs.msg import PoseStamped,PoseWithCovarianceStamped
from nav_msgs.msg import Odometry
import tf
from tf2_msgs.msg import TFMessage
from std_msgs.msg import Int32, Float64, String

drone_name = os.getenv('DRONE_NAME') #environment variable set in bashrc(or exported in terminal)

class multiplexer():

    def __init__(self):

        # Mode
        self.mode = "" # Not using String(), save .data for ease of reading
        rospy.Subscriber(drone_name + '/hri_mode', String, self.mode_callback)

        # Follow Me
        self.follow_me_pos = PoseWithCovarianceStamped() ########################
        rospy.Subscriber(drone_name + '/uav_all/follow_me_target_pose',  PoseWithCovarianceStamped, self.position_callback)

        # Go There
        self.uav_go_there_pos = PoseWithCovarianceStamped()
        rospy.Subscriber(drone_name + '/command/pose',  PoseWithCovarianceStamped, self.uav_go_there_callback)
        self.uav_go_there_yaw = Float64()
        rospy.Subscriber(drone_name + '/command/yaw',  Float64, self.uav_go_there_yaw_callback)

        # Publish topic for planner
        uav_publish_topic = drone_name + "/teaming_planner/assigned_virtual_position"
        uav_publisher = rospy.Publisher(uav_publish_topic , PoseStamped,queue_size=1)

        # Local Position Callback
        self.uav_pos = PoseStamped()
        rospy.Subscriber(drone_name + '/mavros/local_position/pose',  PoseStamped, self.uav_callback)
        self.uav_go_there_pos.pose.pose.position.z=0 #initalise to 0 for takeover

        rate = rospy.Rate(20.0)

        while not rospy.is_shutdown():

            cmd = PoseStamped()

            # Send Information to Concensus Global Path or Formation Planner; When process if completed, send new waypoints to Sense & Avoid
            if self.mode=="Follow_Me":
                # print("FM")
                cmd.pose.position.x=self.follow_me_pos.pose.pose.position.x
                cmd.pose.position.y=self.follow_me_pos.pose.pose.position.y
                cmd.pose.position.z=self.follow_me_pos.pose.pose.position.z

                cmd.pose.orientation.x=self.follow_me_pos.pose.pose.orientation.x
                cmd.pose.orientation.y=self.follow_me_pos.pose.pose.orientation.y
                cmd.pose.orientation.z=self.follow_me_pos.pose.pose.orientation.z
                cmd.pose.orientation.w=self.follow_me_pos.pose.pose.orientation.w

            # Send waypoints from human directly to Sense & Avoid
            # MIGHT NEED TO STAGGER YAW ALSO
            elif self.mode=="Go_There":
                # print("GT")
                # If there is go there position sent, go to
                if self.uav_go_there_pos.pose.pose.position.z != 0:
                    cmd.pose.position.x=self.uav_go_there_pos.pose.pose.position.x
                    cmd.pose.position.y=self.uav_go_there_pos.pose.pose.position.y
                    cmd.pose.position.z=1

                    cmd.pose.orientation.x=self.uav_go_there_pos.pose.pose.orientation.x
                    cmd.pose.orientation.y=self.uav_go_there_pos.pose.pose.orientation.y
                    cmd.pose.orientation.z=self.uav_go_there_pos.pose.pose.orientation.z
                    cmd.pose.orientation.w=self.uav_go_there_pos.pose.pose.orientation.w
                # If there is no position sent yet, hover at current spot
                else:
                    cmd.pose.position.x=self.uav_pos.pose.position.x
                    cmd.pose.position.y=self.uav_pos.pose.position.y
                    cmd.pose.position.z=self.uav_pos.pose.position.z

                    cmd.pose.orientation.x=self.uav_pos.pose.orientation.x
                    cmd.pose.orientation.y=self.uav_pos.pose.orientation.y
                    cmd.pose.orientation.z=self.uav_pos.pose.orientation.z
                    cmd.pose.orientation.w=self.uav_pos.pose.orientation.w

            # Read Yaw command from HRI and send sweep command to Sense & Avoid
            elif self.mode=="Sweep":
                self.beginsweep() # Slows down the sweep command
                pass

            elif self.mode=="Distract":
                pass


            else:
                print("No Mode or Invalid Mode")

                cmd.pose.position.x=self.uav_pos.pose.position.x
                cmd.pose.position.y=self.uav_pos.pose.position.y
                cmd.pose.position.z=self.uav_pos.pose.position.z

                cmd.pose.orientation.x=self.uav_pos.pose.orientation.x
                cmd.pose.orientation.y=self.uav_pos.pose.orientation.y
                cmd.pose.orientation.z=self.uav_pos.pose.orientation.z
                cmd.pose.orientation.w=self.uav_pos.pose.orientation.w
                


            print(self.mode,[cmd.pose.position.x,cmd.pose.position.y,cmd.pose.position.z])
            uav_publisher.publish(cmd)

            rate.sleep()

    # Slows down sweep to a managable speed
    def beginsweep(self):
        pass

    def position_callback(self,data):
        self.follow_me_pos=data

    def mode_callback(self,data):
        self.mode=data.data

    def uav_go_there_callback(self,data):
        self.uav_go_there_pos=data

    
    def uav_go_there_yaw_callback(self,data):
        self.uav_go_there_pos=data
    
    def uav_callback(self,data):
        self.uav_pos=data
    



if __name__ == '__main__':
    rospy.init_node(drone_name + '_Mode_Manager')

    node = multiplexer()

    rospy.spin()