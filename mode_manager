#!/usr/bin/env python

## Mode Manager listens to inputs and selectively rebroadcast outputs based on the human input
## The multiplexer also implements safety conditions to ensure the uav hovers when no new data is being sent or another intensive node is buffering
  
import rospy
import math
import os
from geometry_msgs.msg import PoseStamped, Point
from nav_msgs.msg import Odometry
from tf.transformations import euler_from_quaternion
from std_msgs.msg import Int32, Float64, String, Bool, Float32
import numpy as np
from borealis_hri_msgs.msg import Borealis_HRI_Output
import time

drone_name = os.getenv('DRONE_NAME') #environment variable set in bashrc(or exported in terminal)
drone_number = int(os.getenv('DRONE_NUMBER')) #environment variable set in bashrc(or exported in terminal)
rate = 20 # Hz

class multiplexer():

    def __init__(self):

        global rate
        
        # # Follow Me
        # self.follow_me_pos = PoseWithCovarianceStamped() ########################
        # rospy.Subscriber(drone_name + '/uav_all/follow_me_target_pose',  PoseWithCovarianceStamped, self.follow_me_callback)

        # # Go There
        # self.uav_go_there_pos = PoseWithCovarianceStamped()
        # rospy.Subscriber(drone_name + '/command/pose',  PoseWithCovarianceStamped, self.uav_go_there_callback)
        # self.uav_go_there_yaw = Float64()
        # rospy.Subscriber(drone_name + '/command/yaw',  Float64, self.uav_go_there_yaw_callback)

        self.sweeparr=[]

        # Teaming Planner topics
        teaming_pub = rospy.Publisher(drone_name + "/activate_teaming_planner" , Bool,queue_size=1) # pub once
        self.teaming_setpoint = PoseStamped()
        self.prevteaming_setpoint = PoseStamped()
        rospy.Subscriber(drone_name + "/teaming_planner/mavros_assigned_virtual_position",  PoseStamped, self.teaming_planner_callback)
        # teaming_sub.unregister()
        # teaming_pub.unregister()

        # # Output for Sense&Avoid
        drone_position_publisher = rospy.Publisher(drone_name + "/command/pose", PoseStamped,queue_size=1)
        drone_yaw_publisher = rospy.Publisher(drone_name + "/command/yaw", Float64,queue_size=1)
        drone_mode_publisher = rospy.Publisher(drone_name + "/hri_mode", String,queue_size=1)
        self.setpoint = PoseStamped()
        self.prevsetpoint = PoseStamped()
        rospy.Subscriber(drone_name + "/mavros/setpoint_position/local", PoseStamped, self.setpoint_callback) # To check if the S&A planner has finished planning
        
        # Use Enable this to determine which enable debug message for which stage of planning the drone is at
        planner_status = True # Enable debugging output
        self.planner_status_publisher = rospy.Publisher(drone_name + "/planner_status", String,queue_size=1)
        self.prevplanner_state = ""

        # Local Position Callback
        self.uav_pos = uav()
        rospy.Subscriber(drone_name + '/mavros/local_position/pose',  PoseStamped, self.local_position_callback)

        # Human Input
        rospy.Subscriber('/borealis_hri_output_topic', Borealis_HRI_Output, self.human_callback)
        self.human_command = Borealis_HRI_Output()
        self.prevmode = ""
        self.pos_command = Point()
        self.prevpos_command = Point()
        self.yaw_command = Float32()

         # The problematic thing about this array type is that if there is no command being sent yet, the list index is out of range. Hence, initalise the current position of the uav first to prevent code from crashing
        if self.human_command.uav_state_list == [] or self.human_command.uav_pose_array.poses == []:
            self.mode = "Standby"
            self.pos_command.x = self.uav_pos.x
            self.pos_command.y = self.uav_pos.y
            self.pos_command.z = self.uav_pos.z
            self.yaw_command = euler_from_quaternion([self.uav_pos.rx,self.uav_pos.ry,self.uav_pos.rz,self.uav_pos.rw])[2]
        else:
            self.mode =self.human_command.uav_state_list[drone_number-1]
            self.pos_command=self.human_command.uav_pose_array.poses[drone_number-1].position
            self.yaw_command=self.human_command.uav_yaw_list[drone_number-1]

        prevcmd = PoseStamped()
        self.rosrate=rospy.Rate(rate)

        time.sleep(0.1)

        while not rospy.is_shutdown():

            cmd = PoseStamped()

            # Initalise one time commands
            if self.mode != self.prevmode:
                if self.mode=="Follow_Me" or self.mode=="Go There":
                    teaming_pub.publish(True)
                elif self.mode=="Sweep":
                    self.beginsweep=0
                elif self.mode=="Distract":
                    pass
                else:
                    print("No Mode or Invalid Mode")
            self.prevmode=self.mode

            # Send Information to Concensus Global Path or Formation Planner; When process if completed, send new waypoints to Sense & Avoid
            if self.mode=="Follow_Me":
                # print("FM")
                if self.teaming_setpoint.pose.position.x != 0:
                    cmd.pose.position.x=self.teaming_setpoint.pose.position.x
                    cmd.pose.position.y=self.teaming_setpoint.pose.position.y
                    cmd.pose.position.z=self.teaming_setpoint.pose.position.z

                    cmd.pose.orientation.x=self.teaming_setpoint.pose.orientation.x
                    cmd.pose.orientation.y=self.teaming_setpoint.pose.orientation.y
                    cmd.pose.orientation.z=self.teaming_setpoint.pose.orientation.z
                    cmd.pose.orientation.w=self.teaming_setpoint.pose.orientation.w

                    # Print out debug messages for each stage of planning
                    if planner_status == True:
                        self.planner_debug()
                else:
                    rospy.loginfo("No new follow me setpoint sent, hovering")
                    cmd.pose.position.x=self.uav_pos.x
                    cmd.pose.position.y=self.uav_pos.y
                    cmd.pose.position.z=self.uav_pos.z

                    cmd.pose.orientation.x=self.uav_pos.rx
                    cmd.pose.orientation.y=self.uav_pos.ry
                    cmd.pose.orientation.z=self.uav_pos.rz
                    cmd.pose.orientation.w=self.uav_pos.rw

            # Send waypoints from human directly to Sense & Avoid
            # MIGHT NEED TO STAGGER YAW ALSO
            elif self.mode=="Go_There":
                # print("GT")
                if self.teaming_setpoint.pose.position.x != 0:
                    cmd.pose.position.x=self.teaming_setpoint.pose.position.x
                    cmd.pose.position.y=self.teaming_setpoint.pose.position.y
                    cmd.pose.position.z=self.teaming_setpoint.pose.position.z

                    cmd.pose.orientation.x=self.teaming_setpoint.pose.orientation.x
                    cmd.pose.orientation.y=self.teaming_setpoint.pose.orientation.y
                    cmd.pose.orientation.z=self.teaming_setpoint.pose.orientation.z
                    cmd.pose.orientation.w=self.teaming_setpoint.pose.orientation.w

                    # Print out debug messages for each stage of planning
                    if planner_status == True:
                        self.planner_debug()
                else:
                    rospy.loginfo("No new go there setpoint sent, hovering")
                    cmd.pose.position.x=self.uav_pos.x
                    cmd.pose.position.y=self.uav_pos.y
                    cmd.pose.position.z=self.uav_pos.z

                    cmd.pose.orientation.x=self.uav_pos.rx
                    cmd.pose.orientation.y=self.uav_pos.ry
                    cmd.pose.orientation.z=self.uav_pos.rz
                    cmd.pose.orientation.w=self.uav_pos.rw


            # Read Yaw command from HRI and send sweep command to Sense & Avoid
            elif self.mode=="Sweep":
                # print("Sweep")
                # desiredyaw = math.radians(self.slowsweep(self.yaw_command)) # Slows down the sweep command
                # print(desiredyaw)
                self.yaw_command = math.radians(self.slowsweep(45)) # Slows down the sweep command
            elif self.mode=="Distract":
                # print("Distract")
                cmd.pose.position.x=self.pos_command.x
                cmd.pose.position.y=self.pos_command.y
                cmd.pose.position.z=self.pos_command.z

                cmd.pose.orientation.x=self.uav_pos.rx
                cmd.pose.orientation.y=self.uav_pos.ry
                cmd.pose.orientation.z=self.uav_pos.rz
                cmd.pose.orientation.w=self.uav_pos.rw

            else:
                # if self.mode=="Standby":
                #     # print("In Standby Mode after Sweep")
                #     pass
                # else:
                #     # print("No Mode or Invalid Mode")
                #     pass

                cmd.pose.position.x=self.uav_pos.x
                cmd.pose.position.y=self.uav_pos.y
                cmd.pose.position.z=self.uav_pos.z

                cmd.pose.orientation.x=self.uav_pos.rx
                cmd.pose.orientation.y=self.uav_pos.ry
                cmd.pose.orientation.z=self.uav_pos.rz
                cmd.pose.orientation.w=self.uav_pos.rw
                
            # Always publish the pose, but only print if the pose differs
            if prevcmd != cmd:
                print(self.mode,[cmd.pose.position.x,cmd.pose.position.y,cmd.pose.position.z])
            prevcmd = cmd

            drone_position_publisher.publish(cmd)
            drone_yaw_publisher.publish(self.yaw_command)
            drone_mode_publisher.publish(self.mode)



            self.rosrate.sleep()

    # Slows down sweep to a slower predefined speed, function is made to be non-blocking
    # w is angular velocity in degrees per second
    def slowsweep(self, angle, w=10):
        global rate
        if self.beginsweep==0 and angle != 0:
            (roll, pitch, yaw) = euler_from_quaternion([self.uav_pos.rx, self.uav_pos.ry, self.uav_pos.rz, self.uav_pos.rw])
            print("Yawing from {0} to {1}".format(yaw,angle))
            totaldeg=angle-yaw
            numofsteps=round(totaldeg/w*rate)
            self.sweeparr=[]
            for i in np.arange(yaw, angle + totaldeg/numofsteps, totaldeg/numofsteps):
                    self.sweeparr.append(i)
            self.beginsweep=1

            print(self.sweeparr)
        elif self.beginsweep==0:
            print("Not Sweeping")
            self.mode="Standby"
            return angle
        else:
            if self.sweeparr==[]:
                print("Sweep ended")
                self.mode="Standby"
                return angle
        
        desiredyaw=self.sweeparr[0]
        self.sweeparr.pop(0)
        return desiredyaw
            
    def local_position_callback(self,data):
        self.uav_pos.x=data.pose.position.x
        self.uav_pos.y=data.pose.position.y
        self.uav_pos.z=data.pose.position.z
        self.uav_pos.rx=data.pose.orientation.x
        self.uav_pos.ry=data.pose.orientation.y
        self.uav_pos.rz=data.pose.orientation.z
        self.uav_pos.rw=data.pose.orientation.w

    def human_callback(self,msg):
        if msg.uav_state_list == [] or msg.uav_pose_array.poses == []:
            self.mode = "Standby"
            self.pos_command.x = self.uav_pos.x
            self.pos_command.y = self.uav_pos.y
            self.pos_command.z = self.uav_pos.z
            self.yaw_command = euler_from_quaternion([self.uav_pos.rx,self.uav_pos.ry,self.uav_pos.rz,self.uav_pos.rw])[2]
            print("Human Message not publishing")
        else:
            self.mode =msg.uav_state_list[drone_number-1]
            self.pos_command=msg.uav_pose_array.poses[drone_number-1].position
            self.yaw_command=msg.uav_yaw_list[drone_number-1]

        self.yaw_command=msg.uav_yaw_list[drone_number-1]

    def uav_go_there_callback(self,data):
        self.uav_go_there_pos=data

    def uav_go_there_yaw_callback(self,data):
        self.uav_go_there_pos=data
    
    def uav_callback(self,data):
        self.uav_pos=data

    def setpoint_callback(self,data):
        self.setpoint=data

    def teaming_planner_callback(self,data):
        self.teaming_setpoint = data

    def planner_debug(self):
        if self.pos_command != self.prevpos_command and self.prevplanner_state != "Formation":
            print("New human command sent to Formation Planner")
            self.prevpos_command = self.pos_command
            self.prevplanner_state = "Formation"
            self.planner_status_publisher.publish("Formation")
        elif self.teaming_setpoint != self.prevteaming_setpoint and self.prevplanner_state != "S&A":
            print("Teaming Planner has sent new setpoint to S&A")
            self.prevteaming_setpoint = self.teaming_setpoint
            self.prevplanner_state = "S&A"
            self.planner_status_publisher.publish("S&A")
        elif self.setpoint != self.prevsetpoint and self.prevplanner_state != "Moving":
            print("Sense&Avoid has sent new setpoint to mavros")
            self.setpoint = self.prevsetpoint
            self.prevplanner_state = "Moving"
            self.planner_status_publisher.publish("Moving")
        elif math.sqrt((self.setpoint.pose.position.x - self.uav_pos.x)**2 + (self.setpoint.pose.position.y - self.uav_pos.y)**2 + (self.setpoint.pose.position.z - self.uav_pos.z)**2) < 0.2 and self.prevplanner_state != "Idle":
            print("Drone has reached setpoint, awaiting new human command")
            self.prevplanner_state = "Idle"
            self.planner_status_publisher.publish("Idle")



# UAV class to hold variables
class uav():

    def __init__(self):
        self.x=0
        self.y=0
        self.z=0
        self.rx=0
        self.ry=0
        self.rz=0
        self.rw=0


if __name__ == '__main__':
    rospy.init_node(drone_name + '_Mode_Manager')

    node = multiplexer()

    rospy.spin()